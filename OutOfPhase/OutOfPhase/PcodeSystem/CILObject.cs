/*
 *  Copyright © 1994-2002, 2015-2016 Thomas R. Lawrence
 * 
 *  GNU General Public License
 * 
 *  This file is part of Out Of Phase (Music Synthesis Software)
 * 
 *  Out Of Phase is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
*/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;

namespace OutOfPhase
{
    // https://msdn.microsoft.com/en-us/library/system.reflection.emit.assemblybuilder%28v=vs.110%29.aspx
    // http://www.drdobbs.com/generating-code-at-run-time-with-reflect/184416570?_requestid=36654

    // TODO: A separate assembly is generated for each function. Since we generally compile whole modules at a time,
    // overhead could be reduced by compiling all module functions into one assembly. Also, multiple anonymous expressions
    // in a single entity (e.g. an instrument definition) could be put into one assembly.
    // These code changes are not trivial so they are postponed.
    // [done for the function modules]

    // TODO: add option for "dynamic method" for throw-away evaluations (such as calculator)
    // https://msdn.microsoft.com/en-us/library/system.reflection.emit.dynamicmethod%28v=vs.100%29.aspx

    public class CILAssembly
    {
        public readonly ModuleBuilder moduleBuilder;
        private readonly AssemblyBuilder assemblyBuilder;
        private readonly string assemblyFilename;
        public readonly TypeBuilder typeBuilder;

        private Type generatedType;

        private const bool WriteAssembliesToTempDirectory = false; // enable for debugging

        private static int assemblyNameSequencer;

        public CILAssembly()
        {
            int assemblySequenceNumber = ++assemblyNameSequencer;

            AssemblyName assemblyName = new AssemblyName();
            assemblyName.Name = String.Format("AutoGeneratedAssembly{0}", assemblySequenceNumber);
            if (!WriteAssembliesToTempDirectory)
            {
                assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(
                    assemblyName,
                    AssemblyBuilderAccess.Run);

                moduleBuilder = assemblyBuilder.DefineDynamicModule(
                    assemblyName.Name);
            }
            else
            {
                assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(
                    assemblyName,
                    AssemblyBuilderAccess.RunAndSave,
                    Environment.GetEnvironmentVariable("TEMP"));

                assemblyFilename = assemblyName.Name + ".dll";
                moduleBuilder = assemblyBuilder.DefineDynamicModule(
                    assemblyName.Name,
                    assemblyFilename);
            }

            typeBuilder = moduleBuilder.DefineType("c", TypeAttributes.Public | TypeAttributes.Class);
        }

        public void Finish()
        {
            //
            // Assembly will be immutable after this point (once CreateType() is called)
            //

            generatedType = typeBuilder.CreateType();

            if (WriteAssembliesToTempDirectory)
            {
                // write assembly so we can ildasm.exe it and inspect the generated code
                assemblyBuilder.Save(assemblyFilename);
            }
        }

        public Type GeneratedType
        {
            get
            {
                Debug.Assert(generatedType != null);
                return generatedType;
            }
        }
    }

    public class CILObject
    {
        private readonly CILAssembly cilAssembly;

        private readonly string methodName;

        public readonly DataTypes[] argsTypes;
        public readonly Type[] managedArgsTypes;
        public readonly DataTypes returnType;
        public readonly Type managedReturnType;

        private MethodInfo cachedMethodInfo;

        private string methodNameShim;
        private MethodInfo cachedMethodInfoShim;

        // enable for .NET jitted code generation (disable for pcode)
        public static bool EnableCIL { get { return Program.Config.EnableCIL; } }

        private static int methodNameSequencer;

        public CILObject(
            ManagedFunctionLinkerRec managedFunctionLinker,
            DataTypes[] argsTypes,
            string[] argsNames,
            DataTypes returnType,
            Compiler.ASTExpression ast,
            CILAssembly cilAssembly)
        {
            this.argsTypes = argsTypes;
            this.returnType = returnType;

            this.cilAssembly = cilAssembly;

            GetManagedFunctionSignature(
                argsTypes,
                returnType,
                out managedArgsTypes,
                out managedReturnType);
            int methodSequenceNumber = methodNameSequencer++;
            methodName = String.Format("m{0}", methodSequenceNumber);
            MethodBuilder methodBuilder = cilAssembly.typeBuilder.DefineMethod(
                methodName,
                MethodAttributes.Public | MethodAttributes.Static,
                managedReturnType,
                managedArgsTypes);


            Dictionary<SymbolRec, LocalBuilder> variableTable = new Dictionary<SymbolRec, LocalBuilder>();

            Dictionary<string, int> argumentTable = new Dictionary<string, int>();
            for (int i = 0; i < argsNames.Length; i++)
            {
                argumentTable.Add(argsNames[i], i);
            }

            ILGenerator ilGenerator = methodBuilder.GetILGenerator();
            ast.ILGen(
                this,
                new Compiler.ILGenContext(
                    ilGenerator,
                    argumentTable,
                    variableTable,
                    managedFunctionLinker));
            ilGenerator.Emit(OpCodes.Ret);


            // Generate shim (see explanation at InvokeShim)

            methodNameShim = String.Format("s{0}", methodSequenceNumber);
            MethodBuilder methodBuilderShim = cilAssembly.typeBuilder.DefineMethod(
                methodNameShim,
                MethodAttributes.Public | MethodAttributes.Static,
                typeof(void),
                new Type[0]);
            ILGenerator ilGeneratorShim = methodBuilderShim.GetILGenerator();
            ilGeneratorShim.Emit(OpCodes.Call, typeof(CILThreadLocalStorage).GetMethod("get_CurrentShimArg", BindingFlags.Public | BindingFlags.Static));
            LocalBuilder localShimArg = ilGeneratorShim.DeclareLocal(typeof(StackElement[]));
            ilGeneratorShim.Emit(OpCodes.Stloc, localShimArg);
            for (int i = 0; i < argsTypes.Length; i++)
            {
                ilGeneratorShim.Emit(OpCodes.Ldloc, localShimArg);
                ilGeneratorShim.Emit(OpCodes.Ldc_I4, (int)i);
                ilGeneratorShim.Emit(OpCodes.Ldelema, typeof(StackElement));
                LocalBuilder locElemAddr = ilGeneratorShim.DeclareLocal(typeof(object));
                ilGeneratorShim.Emit(OpCodes.Dup);
                ilGeneratorShim.Emit(OpCodes.Stloc, locElemAddr);
                bool arrayType;
                switch (argsTypes[i])
                {
                    default:
                        Debug.Assert(false);
                        throw new ArgumentException();
                    case DataTypes.eBoolean:
                    case DataTypes.eInteger:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                        ilGeneratorShim.Emit(OpCodes.Ldfld, typeof(ScalarOverlayType).GetField("Integer"));
                        arrayType = false;
                        break;
                    case DataTypes.eFloat:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                        ilGeneratorShim.Emit(OpCodes.Ldfld, typeof(ScalarOverlayType).GetField("Float"));
                        arrayType = false;
                        break;
                    case DataTypes.eDouble:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                        ilGeneratorShim.Emit(OpCodes.Ldfld, typeof(ScalarOverlayType).GetField("Double"));
                        arrayType = false;
                        break;
                    case DataTypes.eArrayOfBoolean:
                    case DataTypes.eArrayOfByte:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                        ilGeneratorShim.Emit(OpCodes.Ldfld, typeof(ReferenceOverlayType).GetField("arrayHandleByte"));
                        arrayType = true;
                        break;
                    case DataTypes.eArrayOfInteger:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                        ilGeneratorShim.Emit(OpCodes.Ldfld, typeof(ReferenceOverlayType).GetField("arrayHandleInt32"));
                        arrayType = true;
                        break;
                    case DataTypes.eArrayOfFloat:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                        ilGeneratorShim.Emit(OpCodes.Ldfld, typeof(ReferenceOverlayType).GetField("arrayHandleFloat"));
                        arrayType = true;
                        break;
                    case DataTypes.eArrayOfDouble:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                        ilGeneratorShim.Emit(OpCodes.Ldfld, typeof(ReferenceOverlayType).GetField("arrayHandleDouble"));
                        arrayType = true;
                        break;
                }
                ilGeneratorShim.Emit(OpCodes.Ldloc, locElemAddr);
                if (arrayType)
                {
                    ilGeneratorShim.Emit(OpCodes.Call, typeof(StackElement).GetMethod("ClearArray"));
                }
                else
                {
                    ilGeneratorShim.Emit(OpCodes.Call, typeof(StackElement).GetMethod("ClearScalar"));
                }
            }
            ilGeneratorShim.Emit(OpCodes.Call, methodBuilder);

            LocalBuilder retVal = ilGeneratorShim.DeclareLocal(managedReturnType);
            ilGeneratorShim.Emit(OpCodes.Stloc, retVal);

            ilGeneratorShim.Emit(OpCodes.Ldloc, localShimArg);
            ilGeneratorShim.Emit(OpCodes.Ldc_I4_0);
            ilGeneratorShim.Emit(OpCodes.Ldelema, typeof(StackElement));
            switch (returnType)
            {
                default:
                    Debug.Assert(false);
                    throw new ArgumentException();
                case DataTypes.eBoolean:
                case DataTypes.eInteger:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ScalarOverlayType).GetField("Integer"));
                    break;
                case DataTypes.eFloat:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ScalarOverlayType).GetField("Float"));
                    break;
                case DataTypes.eDouble:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ScalarOverlayType).GetField("Double"));
                    break;
                case DataTypes.eArrayOfBoolean:
                case DataTypes.eArrayOfByte:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ReferenceOverlayType).GetField("arrayHandleByte"));
                    break;
                case DataTypes.eArrayOfInteger:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ReferenceOverlayType).GetField("arrayHandleInt32"));
                    break;
                case DataTypes.eArrayOfFloat:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ReferenceOverlayType).GetField("arrayHandleFloat"));
                    break;
                case DataTypes.eArrayOfDouble:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ReferenceOverlayType).GetField("arrayHandleDouble"));
                    break;
            }

            ilGeneratorShim.Emit(OpCodes.Ret);
        }

        public MethodInfo MethodInfo
        {
            get
            {
                if (cachedMethodInfo == null)
                {
                    cachedMethodInfo = cilAssembly.GeneratedType.GetMethod(methodName, BindingFlags.Public | BindingFlags.Static);
                    Debug.Assert(cachedMethodInfo != null);
                }
                return cachedMethodInfo;
            }
        }

        public MethodInfo MethodInfoShim
        {
            get
            {
                if (cachedMethodInfoShim == null)
                {
                    cachedMethodInfoShim = cilAssembly.GeneratedType.GetMethod(methodNameShim, BindingFlags.Public | BindingFlags.Static);
                    Debug.Assert(cachedMethodInfoShim != null);
                }
                return cachedMethodInfoShim;
            }
        }

        public EvalErrors Invoke(object[] args, out object result)
        {
            result = null;
            try
            {
                result = MethodInfo.Invoke(
                    null/*obj*/,
                    args);
            }
            catch (ArgumentException exception)
            {
                // Catch mismatched arguments - should never happen since we own the code generation
                Debug.Assert(false, "invoke argument mismatch exception", exception.ToString());
                throw;
            }
            catch (TargetInvocationException exception)
            {
                if (exception.InnerException is OutOfMemoryException)
                {
                    return EvalErrors.eEvalOutOfMemory;
                }
                else if (exception.InnerException is DivideByZeroException)
                {
                    return EvalErrors.eEvalDivideByZero;
                }
                else if (exception.InnerException is NullReferenceException)
                {
                    return EvalErrors.eEvalArrayDoesntExist;
                }
                else if (exception.InnerException is IndexOutOfRangeException)
                {
                    return EvalErrors.eEvalArraySubscriptOutOfRange;
                }
                else if (exception.InnerException is SignatureMismatchException)
                {
                    return EvalErrors.eEvalFunctionSignatureMismatch;
                }
                else if (exception.InnerException is PcodeExterns.EvalErrorException)
                {
                    // from managed code generated calls to IEvaluationContext.Invoke()
                    return ((PcodeExterns.EvalErrorException)(exception.InnerException)).Error;
                }
                else
                {
                    Debug.Assert(false, "unhandled exception from target code", exception.ToString());
                    throw;
                }
            }
            catch (Exception exception)
            {
                Debug.Assert(false, "unhandled invoke exception", exception.ToString());
                throw;
            }
            return EvalErrors.eEvalNoError;
        }

        // InvokeShim() is a fast custom-marshaled invocation for anonymous function entry. The above Invoke() standard method
        // has the following problems:
        // - runtime type checking (unneeded - we always know the types statically and there is no variance)
        // - memory allocation of the object[] array (and another copy made in MethodBase::CheckArguments()) as well as boxing
        //   of individual arguments (most of which are of type double)
        // Since we don't need that, we generate shim code to marshal the expected arguments directly from StackElement[] to
        // a static-bound direct call in CIL.
        // The one hitch is that there is no static invoke in reflection, so passing StackElement[] to the shim would still
        // incur a copy in CheckArgs() even when we reuse our object[] arg array. To avoid even this, the argument is passed
        // in a thread-global variable accessed via the CILThreadLocalStorage.CurrentShimArg property. This is very short-lived:
        // the property is set immediately before the invoke, and read as the first instruction of the shim. There shouldn't
        // be any reentrance issues with the approach.
        // One final note: anonymous function entry currently always sets up the args as the only values on the stack and
        // returns the result in Stack[0]. Therefore, passing StackPtr is not neccesary (it will always equal the number of
        // function arguments). In future, if there is some sort of reetrant interop supported on the same Stack (e.g. calling
        // an extern application function, which in turn calls into user code again), this would need to be passed into the
        // shim as well (among many other changes required).
        public EvalErrors InvokeShim(StackElement[] Stack, ref int StackPtr)
        {
            try
            {
                Debug.Assert(StackPtr == argsTypes.Length);
                CILThreadLocalStorage.CurrentShimArg = Stack;
                MethodInfoShim.Invoke(null, null);
                CILThreadLocalStorage.CurrentShimArg = null;
                StackPtr -= argsTypes.Length;
                //StackPtr = StackPtr - 1/*retaddr*/ + 1/*retval*/; - no-op
            }
            catch (TargetInvocationException exception)
            {
                if (exception.InnerException is OutOfMemoryException)
                {
                    return EvalErrors.eEvalOutOfMemory;
                }
                else if (exception.InnerException is DivideByZeroException)
                {
                    return EvalErrors.eEvalDivideByZero;
                }
                else if (exception.InnerException is NullReferenceException)
                {
                    return EvalErrors.eEvalArrayDoesntExist;
                }
                else if (exception.InnerException is IndexOutOfRangeException)
                {
                    return EvalErrors.eEvalArraySubscriptOutOfRange;
                }
                else if (exception.InnerException is SignatureMismatchException)
                {
                    return EvalErrors.eEvalFunctionSignatureMismatch;
                }
                else if (exception.InnerException is PcodeExterns.EvalErrorException)
                {
                    // from managed code generated calls to IEvaluationContext.Invoke()
                    return ((PcodeExterns.EvalErrorException)(exception.InnerException)).Error;
                }
                else
                {
                    Debug.Assert(false, "unhandled exception from target code", exception.ToString());
                    throw;
                }
            }
            catch (Exception exception)
            {
                Debug.Assert(false, "unhandled invoke exception", exception.ToString());
                throw;
            }

            return EvalErrors.eEvalNoError;
        }

        // Thrown by generated code when actual function signature doesn't match expected signature. This should happen
        // much less often now that whole program compilation is used, but hasn't been proven ruled out. The runtime
        // cost is one compare-and-branch per function call.
        // TODO: provide more specific information about mismatch (i.e. which arg, or retval, and line number)
        public class SignatureMismatchException : Exception
        {
            public SignatureMismatchException()
            {
            }
        }

        public static Type GetManagedType(DataTypes type)
        {
            switch (type)
            {
                default:
                    Debug.Assert(false);
                    throw new ArgumentException();
                case DataTypes.eBoolean:
                    return typeof(Boolean);
                case DataTypes.eInteger:
                    return typeof(Int32);
                case DataTypes.eFloat:
                    return typeof(Single);
                case DataTypes.eDouble:
                    return typeof(Double);
                case DataTypes.eArrayOfBoolean:
                case DataTypes.eArrayOfByte:
                    return typeof(ArrayHandleByte);
                case DataTypes.eArrayOfInteger:
                    return typeof(ArrayHandleInt32);
                case DataTypes.eArrayOfFloat:
                    return typeof(ArrayHandleFloat);
                case DataTypes.eArrayOfDouble:
                    return typeof(ArrayHandleDouble);
            }
        }

        public static void GetManagedFunctionSignature(
            DataTypes[] argsTypes,
            DataTypes returnType,
            out Type[] managedArgsTypes,
            out Type managedReturnType)
        {
            managedArgsTypes = new Type[argsTypes.Length];
            for (int i = 0; i < managedArgsTypes.Length; i++)
            {
                managedArgsTypes[i] = GetManagedType(argsTypes[i]);
            }
            managedReturnType = GetManagedType(returnType);
        }
    }

    public class CILThreadLocalStorage
    {
        [ThreadStaticAttribute]
        private static CILThreadLocalStorage threadLocal = null;
        [ThreadStaticAttribute]
        private static CILThreadLocalStorage threadFreeList = null;

        private PcodeSystem.IEvaluationContext EvaluationContext;
        private IntPtr[] FunctionPointers;
        private int[] FunctionSignatures;

        private StackElement[] ShimArg;

        private CILThreadLocalStorage previous;

        private CILThreadLocalStorage()
        {
        }

        private void Init(
            PcodeSystem.IEvaluationContext EvaluationContext,
            IntPtr[] FunctionPointers,
            int[] FunctionSignatures,
            CILThreadLocalStorage previous)
        {
            this.EvaluationContext = EvaluationContext;
            this.FunctionPointers = FunctionPointers;
            this.FunctionSignatures = FunctionSignatures;

            this.previous = previous;
        }

        public static PcodeSystem.IEvaluationContext CurrentEvaluationContext { get { return threadLocal.EvaluationContext; } }
        public static IntPtr[] CurrentFunctionPointers { get { return threadLocal.FunctionPointers; } }
        public static int[] CurrentFunctionSignatures { get { return threadLocal.FunctionSignatures; } }

        public static StackElement[] CurrentShimArg { get { return threadLocal.ShimArg; } set { threadLocal.ShimArg = value; } }

        public static void Push(
            PcodeSystem.IEvaluationContext EvaluationContext,
            IntPtr[] FunctionPointers,
            int[] FunctionSignatures)
        {
            CILThreadLocalStorage top = threadFreeList;
            if (top == null)
            {
                top = new CILThreadLocalStorage();
            }
            else
            {
                threadFreeList = threadFreeList.previous;
            }
            top.Init(EvaluationContext, FunctionPointers, FunctionSignatures, threadLocal);
            threadLocal = top;
        }

        public static void Pop()
        {
            Debug.Assert(threadLocal != null);

            CILThreadLocalStorage temp = threadLocal;

            threadLocal = threadLocal.previous;

            temp.previous = threadFreeList;
            threadFreeList = temp;
        }
    }
}
