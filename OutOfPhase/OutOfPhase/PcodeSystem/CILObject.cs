/*
 *  Copyright © 1994-2002, 2015-2016 Thomas R. Lawrence
 * 
 *  GNU General Public License
 * 
 *  This file is part of Out Of Phase (Music Synthesis Software)
 * 
 *  Out Of Phase is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
*/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace OutOfPhase
{
    // https://msdn.microsoft.com/en-us/library/system.reflection.emit.assemblybuilder%28v=vs.110%29.aspx
    // http://www.drdobbs.com/generating-code-at-run-time-with-reflect/184416570?_requestid=36654

    // TODO: A separate assembly is generated for each function. Since we generally compile whole modules at a time,
    // overhead could be reduced by compiling all module functions into one assembly. Also, multiple anonymous expressions
    // in a single entity (e.g. an instrument definition) could be put into one assembly.
    // These code changes are not trivial so they are postponed.
    // [done for the function modules]

    // TODO: add option for "dynamic method" for throw-away evaluations (such as calculator)
    // https://msdn.microsoft.com/en-us/library/system.reflection.emit.dynamicmethod%28v=vs.100%29.aspx

    public class CILAssembly
    {
        public readonly ModuleBuilder moduleBuilder;
        private readonly AssemblyBuilder assemblyBuilder;
        private readonly string assemblyFilename;
        public readonly TypeBuilder typeBuilder;

        private Type generatedType;

        private const bool WriteAssembliesToTempDirectory = false; // enable for debugging

        private static int assemblyNameSequencer;

        public CILAssembly()
        {
            int assemblySequenceNumber = ++assemblyNameSequencer;

            AssemblyName assemblyName = new AssemblyName();
            assemblyName.Name = String.Format("AutoGeneratedAssembly{0}", assemblySequenceNumber);
            if (!WriteAssembliesToTempDirectory)
            {
                assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(
                    assemblyName,
                    AssemblyBuilderAccess.Run);

                moduleBuilder = assemblyBuilder.DefineDynamicModule(
                    assemblyName.Name);
            }
            else
            {
                assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(
                    assemblyName,
                    AssemblyBuilderAccess.RunAndSave,
                    Environment.GetEnvironmentVariable("TEMP"));

                assemblyFilename = assemblyName.Name + ".dll";
                moduleBuilder = assemblyBuilder.DefineDynamicModule(
                    assemblyName.Name,
                    assemblyFilename);
            }

            typeBuilder = moduleBuilder.DefineType("c", TypeAttributes.Public | TypeAttributes.Class);
        }

        public void Finish()
        {
            //
            // Assembly will be immutable after this point (once CreateType() is called)
            //

            generatedType = typeBuilder.CreateType();

            if (WriteAssembliesToTempDirectory)
            {
                // write assembly so we can ildasm.exe it and inspect the generated code
                assemblyBuilder.Save(assemblyFilename);
            }
        }

        public Type GeneratedType
        {
            get
            {
                Debug.Assert(generatedType != null);
                return generatedType;
            }
        }
    }

    public class CILObject
    {
        private readonly CILAssembly cilAssembly;

        private readonly string methodName;

        public readonly DataTypes[] argsTypes;
        public readonly Type[] managedArgsTypes;
        public readonly DataTypes returnType;
        public readonly Type managedReturnType;

        private MethodInfo cachedMethodInfo;

        private string methodNameShim;
        private MethodInfo cachedMethodInfoShim;

        // enable for .NET jitted code generation (disable for pcode)
        public static bool EnableCIL { get { return Program.Config.EnableCIL; } }

        private static int methodNameSequencer;

        public CILObject(
            ManagedFunctionLinkerRec managedFunctionLinker,
            DataTypes[] argsTypes,
            string[] argsNames,
            DataTypes returnType,
            Compiler.ASTExpression ast,
            CILAssembly cilAssembly,
            bool argsByRef)
        {
            this.argsTypes = argsTypes;
            this.returnType = returnType;

            this.cilAssembly = cilAssembly;

            GetManagedFunctionSignature(
                argsTypes,
                returnType,
                out managedArgsTypes,
                out managedReturnType);
            int methodSequenceNumber = methodNameSequencer++;
            methodName = String.Format("m{0}", methodSequenceNumber);
            MethodBuilder methodBuilder;
            if (!argsByRef)
            {
                methodBuilder = cilAssembly.typeBuilder.DefineMethod(
                    methodName,
                    MethodAttributes.Public | MethodAttributes.Static,
                    managedReturnType,
                    managedArgsTypes);
            }
            else
            {
                Type[] managedArgsTypesByRef = new Type[managedArgsTypes.Length];
                for (int i = 0; i < managedArgsTypesByRef.Length; i++)
                {
                    managedArgsTypesByRef[i] = managedArgsTypes[i].MakeByRefType();
                }
                methodBuilder = cilAssembly.typeBuilder.DefineMethod(
                    methodName,
                    MethodAttributes.Public | MethodAttributes.Static,
                    managedReturnType,
                    managedArgsTypesByRef);
            }

            ILGenerator ilGenerator = methodBuilder.GetILGenerator();

            Dictionary<SymbolRec, LocalBuilder> variableTable = new Dictionary<SymbolRec, LocalBuilder>();

            Dictionary<string, int> argumentTable = new Dictionary<string, int>();
            Dictionary<string, LocalBuilder> localArgMap = new Dictionary<string, LocalBuilder>();
            List<LocalBuilder> localArgs = new List<LocalBuilder>();
            if (!argsByRef)
            {
                for (int i = 0; i < argsNames.Length; i++)
                {
                    argumentTable.Add(argsNames[i], i);
                }
            }
            else
            {
                for (int i = 0; i < argsNames.Length; i++)
                {
                    LocalBuilder localForArg = ilGenerator.DeclareLocal(managedArgsTypes[i]);
                    localArgs.Add(localForArg);
                    localArgMap.Add(argsNames[i], localForArg);
                    ilGenerator.Emit(OpCodes.Ldarg, i);
                    switch (argsTypes[i])
                    {
                        default:
                            Debug.Assert(false);
                            throw new ArgumentException();
                        case DataTypes.eBoolean:
                        case DataTypes.eInteger:
                            ilGenerator.Emit(OpCodes.Ldind_I4);
                            break;
                        case DataTypes.eFloat:
                            ilGenerator.Emit(OpCodes.Ldind_R4);
                            break;
                        case DataTypes.eDouble:
                            ilGenerator.Emit(OpCodes.Ldind_R8);
                            break;
                        case DataTypes.eArrayOfBoolean:
                        case DataTypes.eArrayOfByte:
                        case DataTypes.eArrayOfInteger:
                        case DataTypes.eArrayOfFloat:
                        case DataTypes.eArrayOfDouble:
                            ilGenerator.Emit(OpCodes.Ldind_Ref);
                            break;
                    }
                    ilGenerator.Emit(OpCodes.Stloc, localForArg);
                }
            }

            ast.ILGen(
                this,
                new Compiler.ILGenContext(
                    ilGenerator,
                    argumentTable,
                    variableTable,
                    managedFunctionLinker,
                    argsByRef,
                    localArgMap));

            if (argsByRef)
            {
                for (int i = 0; i < argsNames.Length; i++)
                {
                    ilGenerator.Emit(OpCodes.Ldarg, i);
                    ilGenerator.Emit(OpCodes.Ldloc, localArgs[i]);
                    switch (argsTypes[i])
                    {
                        default:
                            Debug.Assert(false);
                            throw new ArgumentException();
                        case DataTypes.eBoolean:
                        case DataTypes.eInteger:
                            ilGenerator.Emit(OpCodes.Stind_I4);
                            break;
                        case DataTypes.eFloat:
                            ilGenerator.Emit(OpCodes.Stind_R4);
                            break;
                        case DataTypes.eDouble:
                            ilGenerator.Emit(OpCodes.Stind_R8);
                            break;
                        case DataTypes.eArrayOfBoolean:
                        case DataTypes.eArrayOfByte:
                        case DataTypes.eArrayOfInteger:
                        case DataTypes.eArrayOfFloat:
                        case DataTypes.eArrayOfDouble:
                            ilGenerator.Emit(OpCodes.Stind_Ref);
                            break;
                    }
                }
            }

            ilGenerator.Emit(OpCodes.Ret);


            // Generate shim (see explanation at InvokeShim)

            methodNameShim = String.Format("s{0}", methodSequenceNumber);
            MethodBuilder methodBuilderShim = cilAssembly.typeBuilder.DefineMethod(
                methodNameShim,
                MethodAttributes.Public | MethodAttributes.Static,
                typeof(void),
                new Type[0]);
            ILGenerator ilGeneratorShim = methodBuilderShim.GetILGenerator();
            ilGeneratorShim.Emit(OpCodes.Call, typeof(CILThreadLocalStorage).GetMethod("get_CurrentShimArg", BindingFlags.Public | BindingFlags.Static));
            LocalBuilder localShimArg = ilGeneratorShim.DeclareLocal(typeof(StackElement[]));
            ilGeneratorShim.Emit(OpCodes.Stloc, localShimArg);
            // Compute pointer to last valid stack element (retval slot). In the process, provide a null check
            // and a covering array bounds check. (Subsequent references are done by pointer arithmetic to avoid
            // redundant bounds checks.)
            LocalBuilder ptrToRetVal = null;
            if (Environment.Is64BitProcess)
            {
                ptrToRetVal = ilGeneratorShim.DeclareLocal(typeof(StackElement).MakeByRefType());
                ilGeneratorShim.Emit(OpCodes.Ldloc, localShimArg);
                ilGeneratorShim.Emit(OpCodes.Ldc_I4, (int)argsTypes.Length); // retaddr/retval slot
                ilGeneratorShim.Emit(OpCodes.Ldelema, typeof(StackElement));
                ilGeneratorShim.Emit(OpCodes.Stloc, ptrToRetVal);
            }
            for (int i = 0; i < argsTypes.Length; i++)
            {
                if (Environment.Is64BitProcess)
                {
                    ilGeneratorShim.Emit(OpCodes.Ldloc, ptrToRetVal);
                    ilGeneratorShim.Emit(OpCodes.Ldc_I4, (int)((i - argsTypes.Length) * StackElement.SizeOf()));
                    ilGeneratorShim.Emit(OpCodes.Add);
                }
                else
                {
                    // pointer arithmetic only works on 64-bit -- suspect bug in 32-bit JIT; generated code is very strange
                    // so fall back to regular array refs
                    ilGeneratorShim.Emit(OpCodes.Ldloc, localShimArg);
                    ilGeneratorShim.Emit(OpCodes.Ldc_I4, (int)i);
                    ilGeneratorShim.Emit(OpCodes.Ldelema, typeof(StackElement));
                }
                LocalBuilder locElemAddr = ilGeneratorShim.DeclareLocal(typeof(StackElement).MakeByRefType());
                ilGeneratorShim.Emit(OpCodes.Stloc, locElemAddr);
                ilGeneratorShim.Emit(OpCodes.Ldloc, locElemAddr);
                bool arrayType;
                switch (argsTypes[i])
                {
                    default:
                        Debug.Assert(false);
                        throw new ArgumentException();
                    case DataTypes.eBoolean:
                    case DataTypes.eInteger:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                        ilGeneratorShim.Emit(!argsByRef ? OpCodes.Ldfld : OpCodes.Ldflda, typeof(ScalarOverlayType).GetField("Integer"));
                        arrayType = false;
                        break;
                    case DataTypes.eFloat:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                        ilGeneratorShim.Emit(!argsByRef ? OpCodes.Ldfld : OpCodes.Ldflda, typeof(ScalarOverlayType).GetField("Float"));
                        arrayType = false;
                        break;
                    case DataTypes.eDouble:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                        ilGeneratorShim.Emit(!argsByRef ? OpCodes.Ldfld : OpCodes.Ldflda, typeof(ScalarOverlayType).GetField("Double"));
                        arrayType = false;
                        break;
                    case DataTypes.eArrayOfBoolean:
                    case DataTypes.eArrayOfByte:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                        ilGeneratorShim.Emit(!argsByRef ? OpCodes.Ldfld : OpCodes.Ldflda, typeof(ReferenceOverlayType).GetField("arrayHandleByte"));
                        arrayType = true;
                        break;
                    case DataTypes.eArrayOfInteger:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                        ilGeneratorShim.Emit(!argsByRef ? OpCodes.Ldfld : OpCodes.Ldflda, typeof(ReferenceOverlayType).GetField("arrayHandleInt32"));
                        arrayType = true;
                        break;
                    case DataTypes.eArrayOfFloat:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                        ilGeneratorShim.Emit(!argsByRef ? OpCodes.Ldfld : OpCodes.Ldflda, typeof(ReferenceOverlayType).GetField("arrayHandleFloat"));
                        arrayType = true;
                        break;
                    case DataTypes.eArrayOfDouble:
                        ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                        ilGeneratorShim.Emit(!argsByRef ? OpCodes.Ldfld : OpCodes.Ldflda, typeof(ReferenceOverlayType).GetField("arrayHandleDouble"));
                        arrayType = true;
                        break;
                }
                if (!argsByRef)
                {
                    ilGeneratorShim.Emit(OpCodes.Ldloc, locElemAddr);
                    if (arrayType)
                    {
                        ilGeneratorShim.Emit(OpCodes.Call, typeof(StackElement).GetMethod("ClearArray"));
                    }
                    else
                    {
                        ilGeneratorShim.Emit(OpCodes.Call, typeof(StackElement).GetMethod("ClearScalar"));
                    }
                }
            }
            ilGeneratorShim.Emit(OpCodes.Call, methodBuilder);

            LocalBuilder retVal = ilGeneratorShim.DeclareLocal(managedReturnType);
            ilGeneratorShim.Emit(OpCodes.Stloc, retVal);

            if (Environment.Is64BitProcess)
            {
                ilGeneratorShim.Emit(OpCodes.Ldloc, ptrToRetVal);
                ilGeneratorShim.Emit(OpCodes.Ldc_I4, (int)((!argsByRef ? 0 : argsTypes.Length) - argsTypes.Length) * StackElement.SizeOf());
                ilGeneratorShim.Emit(OpCodes.Add);
            }
            else
            {
                // pointer arithmetic only works on 64-bit -- suspect bug in 32-bit JIT; generated code is very strange
                // so fall back to regular array refs
                ilGeneratorShim.Emit(OpCodes.Ldloc, localShimArg);
                ilGeneratorShim.Emit(OpCodes.Ldc_I4, (int)(!argsByRef ? 0 : argsTypes.Length));
                ilGeneratorShim.Emit(OpCodes.Ldelema, typeof(StackElement));
            }
            switch (returnType)
            {
                default:
                    Debug.Assert(false);
                    throw new ArgumentException();
                case DataTypes.eBoolean:
                case DataTypes.eInteger:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ScalarOverlayType).GetField("Integer"));
                    break;
                case DataTypes.eFloat:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ScalarOverlayType).GetField("Float"));
                    break;
                case DataTypes.eDouble:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("Data"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ScalarOverlayType).GetField("Double"));
                    break;
                case DataTypes.eArrayOfBoolean:
                case DataTypes.eArrayOfByte:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ReferenceOverlayType).GetField("arrayHandleByte"));
                    break;
                case DataTypes.eArrayOfInteger:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ReferenceOverlayType).GetField("arrayHandleInt32"));
                    break;
                case DataTypes.eArrayOfFloat:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ReferenceOverlayType).GetField("arrayHandleFloat"));
                    break;
                case DataTypes.eArrayOfDouble:
                    ilGeneratorShim.Emit(OpCodes.Ldflda, typeof(StackElement).GetField("reference"));
                    ilGeneratorShim.Emit(OpCodes.Ldloc, retVal);
                    ilGeneratorShim.Emit(OpCodes.Stfld, typeof(ReferenceOverlayType).GetField("arrayHandleDouble"));
                    break;
            }

            if (!argsByRef)
            {
                ilGeneratorShim.Emit(OpCodes.Ldc_I4_0);
                ilGeneratorShim.Emit(OpCodes.Call, typeof(CILThreadLocalStorage).GetMethod("set_CurrentShimStackPtr", BindingFlags.Public | BindingFlags.Static));
            }

            ilGeneratorShim.Emit(OpCodes.Ret);
        }

        public MethodInfo MethodInfo
        {
            get
            {
                if (cachedMethodInfo == null)
                {
                    cachedMethodInfo = cilAssembly.GeneratedType.GetMethod(methodName, BindingFlags.Public | BindingFlags.Static);
                    Debug.Assert(cachedMethodInfo != null);
                }
                return cachedMethodInfo;
            }
        }

        public MethodInfo MethodInfoShim
        {
            get
            {
                if (cachedMethodInfoShim == null)
                {
                    cachedMethodInfoShim = cilAssembly.GeneratedType.GetMethod(methodNameShim, BindingFlags.Public | BindingFlags.Static);
                    Debug.Assert(cachedMethodInfoShim != null);
                }
                return cachedMethodInfoShim;
            }
        }

        public EvalErrors Invoke(object[] args, out object result)
        {
            result = null;
            try
            {
                result = MethodInfo.Invoke(
                    null/*obj*/,
                    args);
            }
            catch (ArgumentException exception)
            {
                // Catch mismatched arguments - should never happen since we own the code generation
                Debug.Assert(false, "invoke argument mismatch exception", exception.ToString());
                throw;
            }
            catch (TargetInvocationException exception)
            {
                if (exception.InnerException is OutOfMemoryException)
                {
                    return EvalErrors.eEvalOutOfMemory;
                }
                else if (exception.InnerException is DivideByZeroException)
                {
                    return EvalErrors.eEvalDivideByZero;
                }
                else if (exception.InnerException is NullReferenceException)
                {
                    return EvalErrors.eEvalArrayDoesntExist;
                }
                else if (exception.InnerException is IndexOutOfRangeException)
                {
                    return EvalErrors.eEvalArraySubscriptOutOfRange;
                }
                else if (exception.InnerException is SignatureMismatchException)
                {
                    return EvalErrors.eEvalFunctionSignatureMismatch;
                }
                else if (exception.InnerException is PcodeExterns.EvalErrorException)
                {
                    // from managed code generated calls to IEvaluationContext.Invoke()
                    return ((PcodeExterns.EvalErrorException)(exception.InnerException)).Error;
                }
                else
                {
                    Debug.Assert(false, "unhandled exception from target code", exception.ToString());
                    throw;
                }
            }
            catch (Exception exception)
            {
                Debug.Assert(false, "unhandled invoke exception", exception.ToString());
                throw;
            }
            return EvalErrors.eEvalNoError;
        }

        // InvokeShim() is a fast custom-marshaled invocation for anonymous function entry. The above Invoke() standard method
        // has the following problems:
        // - runtime type checking (unneeded - we always know the types statically and there is no variance)
        // - memory allocation of the object[] array (and another copy made in MethodBase::CheckArguments()) as well as boxing
        //   of individual arguments (most of which are of type double)
        // Since we don't need that, we generate shim code to marshal the expected arguments directly from StackElement[] to
        // a static-bound direct call in CIL.
        // The one hitch is that there is no static invoke in reflection, so passing StackElement[] to the shim would still
        // incur a copy in CheckArgs() even when we reuse our object[] arg array. To avoid even this, the argument is passed
        // in a thread-global variable accessed via the CILThreadLocalStorage.CurrentShimArg property. This is very short-lived:
        // the property is set immediately before the invoke, and read as the first instruction of the shim. There shouldn't
        // be any reentrance issues with the approach.
        // One final note: anonymous function entry currently always sets up the args as the only values on the stack and
        // returns the result in Stack[0]. Therefore, passing StackPtr is not neccesary (it will always equal the number of
        // function arguments). In future, if there is some sort of reetrant interop supported on the same Stack (e.g. calling
        // an extern application function, which in turn calls into user code again), this would need to be passed into the
        // shim as well (among many other changes required).
        public EvalErrors InvokeShim(StackElement[] Stack, ref int StackPtr)
        {
            try
            {
#if DEBUG
                Debug.Assert(StackPtr == argsTypes.Length);
                if ((Stack == null) || !unchecked((uint)Stack.Length >= (uint)StackPtr))
                {
                    Debug.Assert(false);
                    throw new ArgumentException();
                }
#endif
                CILThreadLocalStorage.CurrentShimArg = Stack;
                CILThreadLocalStorage.CurrentShimStackPtr = StackPtr;
                MethodInfoShim.Invoke(null, null);
                CILThreadLocalStorage.CurrentShimArg = null;
                StackPtr = CILThreadLocalStorage.CurrentShimStackPtr;
                //StackPtr -= argsTypes.Length; -- done by shim, but not for special functions (args by ref)
                //StackPtr = StackPtr - 1/*retaddr*/ + 1/*retval*/; -- no-op
            }
            catch (TargetInvocationException exception)
            {
                if (exception.InnerException is OutOfMemoryException)
                {
                    return EvalErrors.eEvalOutOfMemory;
                }
                else if (exception.InnerException is DivideByZeroException)
                {
                    return EvalErrors.eEvalDivideByZero;
                }
                else if (exception.InnerException is NullReferenceException)
                {
                    return EvalErrors.eEvalArrayDoesntExist;
                }
                else if (exception.InnerException is IndexOutOfRangeException)
                {
                    return EvalErrors.eEvalArraySubscriptOutOfRange;
                }
                else if (exception.InnerException is SignatureMismatchException)
                {
                    return EvalErrors.eEvalFunctionSignatureMismatch;
                }
                else if (exception.InnerException is PcodeExterns.EvalErrorException)
                {
                    // from managed code generated calls to IEvaluationContext.Invoke()
                    return ((PcodeExterns.EvalErrorException)(exception.InnerException)).Error;
                }
                else
                {
                    Debug.Assert(false, "unhandled exception from target code", exception.ToString());
                    throw;
                }
            }
            catch (Exception exception)
            {
                Debug.Assert(false, "unhandled invoke exception", exception.ToString());
                throw;
            }

            return EvalErrors.eEvalNoError;
        }

        // Thrown by generated code when actual function signature doesn't match expected signature. This should happen
        // much less often now that whole program compilation is used, but hasn't been proven ruled out. The runtime
        // cost is one compare-and-branch per function call.
        // TODO: provide more specific information about mismatch (i.e. which arg, or retval, and line number)
        public class SignatureMismatchException : Exception
        {
            public SignatureMismatchException()
            {
            }
        }

        public static Type GetManagedType(DataTypes type)
        {
            switch (type)
            {
                default:
                    Debug.Assert(false);
                    throw new ArgumentException();
                case DataTypes.eBoolean:
                    return typeof(Boolean);
                case DataTypes.eInteger:
                    return typeof(Int32);
                case DataTypes.eFloat:
                    return typeof(Single);
                case DataTypes.eDouble:
                    return typeof(Double);
                case DataTypes.eArrayOfBoolean:
                case DataTypes.eArrayOfByte:
                    return typeof(ArrayHandleByte);
                case DataTypes.eArrayOfInteger:
                    return typeof(ArrayHandleInt32);
                case DataTypes.eArrayOfFloat:
                    return typeof(ArrayHandleFloat);
                case DataTypes.eArrayOfDouble:
                    return typeof(ArrayHandleDouble);
            }
        }

        public static void GetManagedFunctionSignature(
            DataTypes[] argsTypes,
            DataTypes returnType,
            out Type[] managedArgsTypes,
            out Type managedReturnType)
        {
            managedArgsTypes = new Type[argsTypes.Length];
            for (int i = 0; i < managedArgsTypes.Length; i++)
            {
                managedArgsTypes[i] = GetManagedType(argsTypes[i]);
            }
            managedReturnType = GetManagedType(returnType);
        }

        public string GetDisassembly()
        {
            StringBuilder result = new StringBuilder();

            DisassembleMethod(MethodInfo, result, true/*tryToEnsureJIT*/);

            result.AppendLine("shim:");
            DisassembleMethod(MethodInfoShim, result, true/*tryToEnsureJIT*/);

            return result.ToString();
        }

        public static string GetDisassembly(string name)
        {
            int separator = name.LastIndexOf('.');
            if (separator < 0)
            {
                return "Invalid method name";
            }
            string typeName = name.Substring(0, separator);
            Type type = Type.GetType(typeName, false/*throw*/);
            if (type == null)
            {
                return "Type does not exist";
            }
            MethodInfo[] methodInfos = type.GetMethods();
            StringBuilder sb = new StringBuilder();
            foreach (MethodInfo methodInfo in methodInfos)
            {
                if (String.Equals(methodInfo.Name, name.Substring(separator + 1)))
                {
                    sb.AppendLine(methodInfo.Name);
                    DisassembleMethod(methodInfo, sb, false/*tryToEnsureJIT*/);
                    sb.AppendLine();
                }
            }
            if (sb.Length == 0)
            {
                return "Type does not implement a method by that name";
            }
            return sb.ToString();
        }

        private static void DisassembleMethod(
            MethodInfo methodInfo,
            StringBuilder result,
            bool tryToEnsureJIT)
        {
#if true    // TODO: this is a total HACK! To do it right requires creating a separate process that activates the CLR debugger
            // interfaces, attaches to this process, enumerates the active state to find the native code segments corresponding
            // to cachedMethodInfo, and then return those to us so we can invoke the disassembler. That's way too much work
            // for the time being.

            // this code could well crash, so make sure autosave has happened.
            MainWindow.DoAutosaveGlobally();

#if true // additional HACK to try to ensure JIT has happened by invoking method with bogus arguments.
            if (tryToEnsureJIT)
            {
                object[] args = new object[methodInfo.GetParameters().Length];
                try
                {
                    object o = methodInfo.Invoke(null, args);
                }
                catch
                {
                }
            }
#endif

            IntPtr codeBaseAddress = methodInfo.MethodHandle.GetFunctionPointer();
        TryAgain:
            int length = 0;

            SharpDisasm.Disassembler.Translator.IncludeAddress = false;
            SharpDisasm.Disassembler.Translator.IncludeBinary = false;

            // HACK to guess the code length:
            // seek to first RET instruction, unless there are branches to the instruction immedately
            // after that RET, in which case, ignore it and keep going.
            List<ulong> addresses = new List<ulong>();
            bool firstReturnSeen = false;
            while (true)
            {
                IntPtr currentAddress = new IntPtr(codeBaseAddress.ToInt64() + length);

                // detect RET or INT3
                bool stop = (Marshal.ReadByte(currentAddress) == 0xC3) || (Marshal.ReadByte(currentAddress) == 0xCC);
                firstReturnSeen = firstReturnSeen || stop;

                SharpDisasm.Disassembler disassembler2 = new SharpDisasm.Disassembler(
                    currentAddress,
                    17,
                    Environment.Is64BitProcess ? SharpDisasm.ArchitectureMode.x86_64 : SharpDisasm.ArchitectureMode.x86_32,
                    (ulong)currentAddress.ToInt64(),
                    true,
                    SharpDisasm.Vendor.Any);

                foreach (SharpDisasm.Instruction instruction in disassembler2.Disassemble())
                {
                    length += instruction.Bytes.Length;

                    string mnemonic = instruction.ToString().Trim();
                    string name = mnemonic;
                    int space = mnemonic.IndexOf(' ');
                    if (space >= 0)
                    {
                        name = name.Substring(0, space);
                    }
                    switch (name)
                    {
                        case "call":
                        case "ja":
                        case "jae":
                        case "jb":
                        case "jbe":
                        case "jc":
                        case "jcxz":
                        case "je":
                        case "jg":
                        case "jge":
                        case "jl":
                        case "jle":
                        case "jmp":
                        case "jna":
                        case "jnae":
                        case "jnb":
                        case "jnbe":
                        case "jnc":
                        case "jne":
                        case "jng":
                        case "jnge":
                        case "jnl":
                        case "jnle":
                        case "jno":
                        case "jnp":
                        case "jns":
                        case "jnz":
                        case "jo":
                        case "jp":
                        case "jpe":
                        case "jpo":
                        case "js":
                        case "jz":
                            string address = mnemonic.Substring(mnemonic.IndexOf(' ')).Trim();
                            if (address.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
                            {
                                // Disassembler doesn't expose absolute target address as property, but it knows it, since it
                                // generates text output. Reverse the text to get the address.                          
                                address = address.Substring(2);
                                ulong target = UInt64.Parse(address, System.Globalization.NumberStyles.HexNumber);
                                if (Environment.Is64BitProcess && (address.Length <= 8))
                                {
                                    target += instruction.Offset & 0xffffffff00000000;
                                }
                                addresses.Add(target);

                                if (String.Equals(name, "jmp") && unchecked(instruction.Offset == (ulong)codeBaseAddress.ToInt64()))
                                {
                                    // if JMP is the first instruction, assume we've hit a trampoline and restart at target
                                    codeBaseAddress = new IntPtr(unchecked((long)target));
                                    goto TryAgain;
                                }
                            }
                            // else could be register indirect addressing mode, etc.

                            if (String.Equals("invalid", name))
                            {
                                length -= instruction.Bytes.Length;
                                stop = true;
                                goto ReallyStop;
                            }

                            // Aux code often terminates with JMP back to main body
                            if (String.Equals("jmp", name))
                            {
                                if (firstReturnSeen) // do not test stop after jmp in main body of code
                                {
                                    stop = true;
                                }
                            }

                            // Aux code also may terminate with CALL to thunk (which pops context and returns to it's caller)
                            // No way to distinguish between that case and normal function calls that may resume execution
                            // at next instruction - so we'll include garbage after in that case. Main risk is of access
                            // violation if at end of mapped region.

                            break;
                    }
                    break;
                }

                IntPtr nextAddress = new IntPtr(codeBaseAddress.ToInt64() + length);

                if (stop)
                {
                    addresses.Sort();
                    int i = 0;
                    while ((i < addresses.Count) && (addresses[i] < (ulong)nextAddress.ToInt64()))
                    {
                        i++;
                    }
                    addresses.RemoveRange(0, i);
                    if ((addresses.Count != 0) && (addresses[0] == (ulong)nextAddress.ToInt64()))
                    {
                        stop = false;
                    }
                }
            ReallyStop:
                if (stop)
                {
                    break;
                }
            }

            SharpDisasm.Disassembler.Translator.IncludeAddress = true;
            SharpDisasm.Disassembler.Translator.IncludeBinary = true;

            SharpDisasm.Disassembler disassembler = new SharpDisasm.Disassembler(
                codeBaseAddress,
                length,
                Environment.Is64BitProcess ? SharpDisasm.ArchitectureMode.x86_64 : SharpDisasm.ArchitectureMode.x86_32,
                (ulong)codeBaseAddress.ToInt64(),
                SharpDisasm.Disassembler.Translator.IncludeBinary,
                SharpDisasm.Vendor.Any);
            foreach (SharpDisasm.Instruction instruction in disassembler.Disassemble())
            {
                result.AppendLine(instruction.ToString());
            }
            result.AppendLine();
#endif
        }
    }

    public class CILThreadLocalStorage
    {
        [ThreadStaticAttribute]
        private static CILThreadLocalStorage threadLocal = null;
        [ThreadStaticAttribute]
        private static CILThreadLocalStorage threadFreeList = null;

        private PcodeSystem.IEvaluationContext EvaluationContext;
        private IntPtr[] FunctionPointers;
        private int[] FunctionSignatures;

        private StackElement[] ShimArg;
        private int ShimStackPtr;

        private CILThreadLocalStorage previous;

        private CILThreadLocalStorage()
        {
        }

        private void Init(
            PcodeSystem.IEvaluationContext EvaluationContext,
            IntPtr[] FunctionPointers,
            int[] FunctionSignatures,
            CILThreadLocalStorage previous)
        {
            this.EvaluationContext = EvaluationContext;
            this.FunctionPointers = FunctionPointers;
            this.FunctionSignatures = FunctionSignatures;

            this.previous = previous;
        }

        public static PcodeSystem.IEvaluationContext CurrentEvaluationContext { get { return threadLocal.EvaluationContext; } }
        public static IntPtr[] CurrentFunctionPointers { get { return threadLocal.FunctionPointers; } }
        public static int[] CurrentFunctionSignatures { get { return threadLocal.FunctionSignatures; } }

        public static StackElement[] CurrentShimArg { get { return threadLocal.ShimArg; } set { threadLocal.ShimArg = value; } }
        public static int CurrentShimStackPtr { get { return threadLocal.ShimStackPtr; } set { threadLocal.ShimStackPtr = value; } }

        public static void Push(
            PcodeSystem.IEvaluationContext EvaluationContext,
            IntPtr[] FunctionPointers,
            int[] FunctionSignatures)
        {
            CILThreadLocalStorage top = threadFreeList;
            if (top == null)
            {
                top = new CILThreadLocalStorage();
            }
            else
            {
                threadFreeList = threadFreeList.previous;
            }
            top.Init(EvaluationContext, FunctionPointers, FunctionSignatures, threadLocal);
            threadLocal = top;
        }

        public static void Pop()
        {
            Debug.Assert(threadLocal != null);

            CILThreadLocalStorage temp = threadLocal;

            threadLocal = threadLocal.previous;

            temp.previous = threadFreeList;
            threadFreeList = temp;
        }
    }
}
