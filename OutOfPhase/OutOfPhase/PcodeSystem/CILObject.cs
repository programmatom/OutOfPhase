/*
 *  Copyright © 1994-2002, 2015-2016 Thomas R. Lawrence
 * 
 *  GNU General Public License
 * 
 *  This file is part of Out Of Phase (Music Synthesis Software)
 * 
 *  Out Of Phase is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
*/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;

namespace OutOfPhase
{
    // https://msdn.microsoft.com/en-us/library/system.reflection.emit.assemblybuilder%28v=vs.110%29.aspx
    // http://www.drdobbs.com/generating-code-at-run-time-with-reflect/184416570?_requestid=36654

    // TODO: A separate assembly is generated for each function. Since we generally compile whole modules at a time,
    // overhead could be reduced by compiling all module functions into one assembly. Also, multiple anonymous expressions
    // in a single entity (e.g. an instrument definition) could be put into one assembly.
    // These code changes are not trivial so they are postponed.
    // [done for the function modules]

    // TODO: add option for "dynamic method" for throw-away evaluations (such as calculator)
    // https://msdn.microsoft.com/en-us/library/system.reflection.emit.dynamicmethod%28v=vs.100%29.aspx

    public class CILAssembly
    {
        public readonly ModuleBuilder moduleBuilder;
        private readonly AssemblyBuilder assemblyBuilder;
        private readonly string assemblyFilename;
        public readonly TypeBuilder typeBuilder;

        private Type generatedType;

        private const bool WriteAssembliesToTempDirectory = false; // enable for debugging

        private static int assemblyNameSequencer;

        public CILAssembly()
        {
            int assemblySequenceNumber = ++assemblyNameSequencer;

            AssemblyName assemblyName = new AssemblyName();
            assemblyName.Name = String.Format("AutoGeneratedAssembly{0}", assemblySequenceNumber);
            if (!WriteAssembliesToTempDirectory)
            {
                assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(
                    assemblyName,
                    AssemblyBuilderAccess.Run);

                moduleBuilder = assemblyBuilder.DefineDynamicModule(
                    assemblyName.Name);
            }
            else
            {
                assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(
                    assemblyName,
                    AssemblyBuilderAccess.RunAndSave,
                    Environment.GetEnvironmentVariable("TEMP"));

                assemblyFilename = assemblyName.Name + ".dll";
                moduleBuilder = assemblyBuilder.DefineDynamicModule(
                    assemblyName.Name,
                    assemblyFilename);
            }

            typeBuilder = moduleBuilder.DefineType("c", TypeAttributes.Public | TypeAttributes.Class);
        }

        public void Finish()
        {
            //
            // Assembly will be immutable after this point (once CreateType() is called)
            //

            generatedType = typeBuilder.CreateType();

            if (WriteAssembliesToTempDirectory)
            {
                // write assembly so we can ildasm.exe it and inspect the generated code
                assemblyBuilder.Save(assemblyFilename);
            }
        }

        public Type GeneratedType
        {
            get
            {
                Debug.Assert(generatedType != null);
                return generatedType;
            }
        }
    }

    public class CILObject
    {
        private readonly CILAssembly cilAssembly;

        private readonly string methodName;

        public readonly DataTypes[] argsTypes;
        public readonly Type[] managedArgsTypes;
        public readonly DataTypes returnType;
        public readonly Type managedReturnType;

        public const bool EnableCIL = true; // enable for .NET jitted code generation (disable for pcode)

        private static int methodNameSequencer;

        public CILObject(
            ManagedFunctionLinkerRec managedFunctionLinker,
            DataTypes[] argsTypes,
            string[] argsNames,
            DataTypes returnType,
            Compiler.ASTExpressionRec ast,
            CILAssembly cilAssembly)
        {
            this.argsTypes = argsTypes;
            this.returnType = returnType;

            this.cilAssembly = cilAssembly;

            GetManagedFunctionSignature(
                argsTypes,
                returnType,
                out managedArgsTypes,
                out managedReturnType);
            int methodSequenceNumber = methodNameSequencer++;
            methodName = String.Format("m{0}", methodSequenceNumber);
            MethodBuilder methodBuilder = cilAssembly.typeBuilder.DefineMethod(
                methodName,
                MethodAttributes.Public | MethodAttributes.Static,
                managedReturnType,
                managedArgsTypes);


            Dictionary<SymbolRec, LocalBuilder> variableTable = new Dictionary<SymbolRec, LocalBuilder>();

            Dictionary<string, int> argumentTable = new Dictionary<string, int>();
            for (int i = 0; i < argsNames.Length; i++)
            {
                argumentTable.Add(argsNames[i], i);
            }

            ILGenerator ilGenerator = methodBuilder.GetILGenerator();
            Compiler.ILGenExpression(
                this,
                new Compiler.ILGenContext(
                    ilGenerator,
                    argumentTable,
                    variableTable,
                    managedFunctionLinker),
                ast);
            ilGenerator.Emit(OpCodes.Ret);
        }

        public MethodInfo MethodInfo
        {
            get
            {
                MethodInfo mi = cilAssembly.GeneratedType.GetMethod(methodName, BindingFlags.Public | BindingFlags.Static);
                Debug.Assert(mi != null);
                return mi;
            }
        }

        // TODO: provide more specific information about mismatch (i.e. which arg, or retval, and line number)
        public class SignatureMismatchException : Exception
        {
            public SignatureMismatchException()
            {
            }
        }

        public EvalErrors Invoke(object[] args, out object result)
        {
            result = null;
            try
            {
                result = MethodInfo.Invoke(
                    null/*obj*/,
                    args);
            }
            catch (ArgumentException exception)
            {
                // Catch mismatched arguments - should never happen since we own the code generation
                Debug.Assert(false, "invoke argument mismatch exception", exception.ToString());
                throw;
            }
            catch (TargetInvocationException exception)
            {
                if (exception.InnerException is OutOfMemoryException)
                {
                    return EvalErrors.eEvalOutOfMemory;
                }
                else if (exception.InnerException is DivideByZeroException)
                {
                    return EvalErrors.eEvalDivideByZero;
                }
                else if (exception.InnerException is NullReferenceException)
                {
                    return EvalErrors.eEvalArrayDoesntExist;
                }
                else if (exception.InnerException is IndexOutOfRangeException)
                {
                    return EvalErrors.eEvalArraySubscriptOutOfRange;
                }
                else if (exception.InnerException is SignatureMismatchException)
                {
                    return EvalErrors.eEvalFunctionSignatureMismatch;
                }
                else if (exception.InnerException is PcodeExterns.EvalErrorException)
                {
                    // from managed code generated calls to IEvaluationContext.Invoke()
                    return ((PcodeExterns.EvalErrorException)(exception.InnerException)).Error;
                }
                else
                {
                    Debug.Assert(false, "unhandled exception from target code", exception.ToString());
                    throw;
                }
            }
            catch (Exception exception)
            {
                Debug.Assert(false, "unhandled invoke exception", exception.ToString());
                throw;
            }
            return EvalErrors.eEvalNoError;
        }

        public static Type GetManagedType(DataTypes type)
        {
            switch (type)
            {
                default:
                    Debug.Assert(false);
                    throw new ArgumentException();
                case DataTypes.eBoolean:
                    return typeof(Boolean);
                case DataTypes.eInteger:
                    return typeof(Int32);
                case DataTypes.eFloat:
                    return typeof(Single);
                case DataTypes.eDouble:
                    return typeof(Double);
                case DataTypes.eArrayOfBoolean:
                case DataTypes.eArrayOfByte:
                    return typeof(ArrayHandleByte);
                case DataTypes.eArrayOfInteger:
                    return typeof(ArrayHandleInt32);
                case DataTypes.eArrayOfFloat:
                    return typeof(ArrayHandleFloat);
                case DataTypes.eArrayOfDouble:
                    return typeof(ArrayHandleDouble);
            }
        }

        public static void GetManagedFunctionSignature(
            DataTypes[] argsTypes,
            DataTypes returnType,
            out Type[] managedArgsTypes,
            out Type managedReturnType)
        {
            managedArgsTypes = new Type[argsTypes.Length];
            for (int i = 0; i < managedArgsTypes.Length; i++)
            {
                managedArgsTypes[i] = GetManagedType(argsTypes[i]);
            }
            managedReturnType = GetManagedType(returnType);
        }
    }

    public class CILThreadLocalStorage
    {
        [ThreadStaticAttribute]
        private static CILThreadLocalStorage threadLocal = null;

        private readonly PcodeSystem.IEvaluationContext EvaluationContext;
        private readonly IntPtr[] FunctionPointers;
        private readonly int[] FunctionSignatures;

        private readonly CILThreadLocalStorage previous;

        private CILThreadLocalStorage(
            PcodeSystem.IEvaluationContext EvaluationContext,
            IntPtr[] FunctionPointers,
            int[] FunctionSignatures,
            CILThreadLocalStorage previous)
        {
            this.EvaluationContext = EvaluationContext;
            this.FunctionPointers = FunctionPointers;
            this.FunctionSignatures = FunctionSignatures;

            this.previous = previous;
        }

        public static PcodeSystem.IEvaluationContext CurrentEvaluationContext { get { return threadLocal.EvaluationContext; } }
        public static IntPtr[] CurrentFunctionPointers { get { return threadLocal.FunctionPointers; } }
        public static int[] CurrentFunctionSignatures { get { return threadLocal.FunctionSignatures; } }

        public static void Push(
            PcodeSystem.IEvaluationContext EvaluationContext,
            IntPtr[] FunctionPointers,
            int[] FunctionSignatures)
        {
            threadLocal = new CILThreadLocalStorage(EvaluationContext, FunctionPointers, FunctionSignatures, threadLocal);
        }

        public static void Pop()
        {
            Debug.Assert(threadLocal != null);
            threadLocal = threadLocal.previous;
        }
    }
}
